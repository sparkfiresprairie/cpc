//
// Created by Xingyuan Wang on 3/17/17.
//

/*
    Write a program to find the nth super ugly number.

    Super ugly numbers are positive numbers whose all prime factors are in the given
    prime list primes of size k. For example, [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32]
    is the sequence of the first 12 super ugly numbers given primes = [2, 7, 13, 19] of
    size 4.

    Note:
    (1) 1 is a super ugly number for any given primes.
    (2) The given numbers in primes are in ascending order.
    (3) 0 < k ≤ 100, 0 < n ≤ 106, 0 < primes[i] < 1000.
    (4) The nth super ugly number is guaranteed to fit in a 32-bit signed integer.
 */

#include "Heap.h"

int nthSuperUglyNumber(int n, vector<int>& primes) {
    // Basic idea is same as ugly number II, new ugly number
    // is generated by multiplying a prime with previous
    // generated ugly number. One catch is need to remove
    // duplicate

    // index decides which ugly number the prime should time with.
    vector<int> index(primes.size(), 0), ugly(n, INT_MAX);
    ugly[0] = 1;
    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < primes.size(); ++j) {
            ugly[i] = min(ugly[i], primes[j] * ugly[index[j]]);
        }
        for (int j = 0; j < primes.size(); ++j) {
            index[j] += (ugly[i] == primes[j] * ugly[index[j]]);
        }
    }
    return ugly[n - 1];
}

// time: O(nk)
// space: O(max(n, k));


//struct PI { // prime & index
//    int prime;
//    int index;
//    PI(int p, int i) : prime(p), index(i) {}
//};
//
//int nthSuperUglyNumber(int n, vector<int>& primes) {
//    vector<int> ugly(n, 0);
//    auto my_greater = [&](PI const& a, PI const& b) {
//        return a.prime * ugly[a.index] > b.prime * ugly[b.index];
//    };
//    priority_queue<PI, vector<PI>, decltype(my_greater)> pq(my_greater);
//    for (int i = 0; i < primes.size(); ++i) {
//        pq.push(PI(primes[i], 0));
//    }
//    ugly[0] = 1;
//    int i = 1;
//    while (i < n) {
//        auto prm = pq.top().prime;
//        auto idx = pq.top().index;
//        int t = prm * ugly[idx];
//        if (t != ugly[i - 1]) ugly[i++] = t;
//        pq.pop();
//        pq.push(PI(prm, idx + 1));
//
//    }
//    return ugly[n - 1];
//}
//
//// time: nlogk
//// space: O(max(n, k));